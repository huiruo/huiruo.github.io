"use strict";(self.webpackChunkprogramming_technology=self.webpackChunkprogramming_technology||[]).push([[7029],{3905:(e,n,r)=>{r.d(n,{Zo:()=>d,kt:()=>m});var t=r(67294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var a=t.createContext({}),c=function(e){var n=t.useContext(a),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},d=function(e){var n=c(e.components);return t.createElement(a.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(r),h=o,m=u["".concat(a,".").concat(h)]||u[h]||p[h]||i;return r?t.createElement(m,l(l({ref:n},d),{},{components:r})):t.createElement(m,l({ref:n},d))}));function m(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=r.length,l=new Array(i);l[0]=h;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=e,s[u]="string"==typeof e?e:o,l[1]=s;for(var c=2;c<i;c++)l[c]=r[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},40676:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=r(87462),o=(r(67294),r(3905));const i={title:"mountIndeterminateComponent\u6784\u5efafiber\u6811",sidebar_position:-2},l=void 0,s={unversionedId:"React/mountIndeterminateComponent\u6784\u5efafiber\u6811",id:"React/mountIndeterminateComponent\u6784\u5efafiber\u6811",title:"mountIndeterminateComponent\u6784\u5efafiber\u6811",description:"beginWork\u524d\u7f6e\u5de5\u4f5c",source:"@site/programming-tech/React/mountIndeterminateComponent\u6784\u5efafiber\u6811.md",sourceDirName:"React",slug:"/React/mountIndeterminateComponent\u6784\u5efafiber\u6811",permalink:"/React/mountIndeterminateComponent\u6784\u5efafiber\u6811",draft:!1,editUrl:"https://github.com/huiruo/programming-tech-website/edit/main/programming-tech/React/mountIndeterminateComponent\u6784\u5efafiber\u6811.md",tags:[],version:"current",sidebarPosition:-2,frontMatter:{title:"mountIndeterminateComponent\u6784\u5efafiber\u6811",sidebar_position:-2},sidebar:"docs",previous:{title:"hook\u548c\u95ed\u5305",permalink:"/React/hook\u548c\u95ed\u5305"},next:{title:"setState\u5f02\u6b65-\u540c\u6b65",permalink:"/React/setState\u5f02\u6b65-\u540c\u6b65"}},a={},c=[{value:"beginWork\u524d\u7f6e\u5de5\u4f5c",id:"beginwork\u524d\u7f6e\u5de5\u4f5c",level:2},{value:"beginWork\u4e4b\u524dworkInProgress\u6839\u8282\u70b9\u6784\u5efa",id:"beginwork\u4e4b\u524dworkinprogress\u6839\u8282\u70b9\u6784\u5efa",level:3},{value:"\u4e3aworkInProgress\u8d4b\u503c-renderRootSync--&gt;prepareFreshStack",id:"\u4e3aworkinprogress\u8d4b\u503c-renderrootsync--preparefreshstack",level:3},{value:"\u7b2c\u4e00\u6b21beginWork\u8c03\u7528updateHostRoot\u8fdb\u884c\u521d\u59cb\u5316:updateHostRoot",id:"\u7b2c\u4e00\u6b21beginwork\u8c03\u7528updatehostroot\u8fdb\u884c\u521d\u59cb\u5316updatehostroot",level:2},{value:"\u9996\u6b21case\u8fdb\u5165HostRoot \u66f4\u65b0updateHostRoot\uff1a",id:"\u9996\u6b21case\u8fdb\u5165hostroot-\u66f4\u65b0updatehostroot",level:3},{value:"\u5f88\u957f\u7684\u51fd\u6570-ChildReconciler\u5b9a\u4e49\u4e86reconcileChildFibers\u7b49\u5f88\u591a\u51fd\u6570",id:"\u5f88\u957f\u7684\u51fd\u6570-childreconciler\u5b9a\u4e49\u4e86reconcilechildfibers\u7b49\u5f88\u591a\u51fd\u6570",level:3},{value:"\u7b2c\u4e8c\u6b21beginWork-case:mountIndeterminateComponent \u6267\u884ccode()",id:"\u7b2c\u4e8c\u6b21beginwork-casemountindeterminatecomponent-\u6267\u884ccode",level:2},{value:"\u91cd\u70b9-code\u51fd\u6570\u521d\u59cb\u5316\u5728renderWithHooks\u8fd9\u91cc\u6267\u884c",id:"\u91cd\u70b9-code\u51fd\u6570\u521d\u59cb\u5316\u5728renderwithhooks\u8fd9\u91cc\u6267\u884c",level:3},{value:"mountIndeterminateComponent()",id:"mountindeterminatecomponent",level:3},{value:"renderWithHooks \u6267\u884ccode()",id:"renderwithhooks-\u6267\u884ccode",level:3},{value:"\u6d41\u7a0b\u56fe-\u6784\u5efafiber\u6811\u6d41\u7a0b",id:"\u6d41\u7a0b\u56fe-\u6784\u5efafiber\u6811\u6d41\u7a0b",level:2},{value:"reconcileChildren \u91cd\u70b9\u51fd\u6570",id:"reconcilechildren-\u91cd\u70b9\u51fd\u6570",level:2},{value:"\u4e0a\u9762\u7684reconcileChildren \u8c03\u7528 reconcileChildFibers",id:"\u4e0a\u9762\u7684reconcilechildren-\u8c03\u7528-reconcilechildfibers",level:2},{value:"\u4e0a\u9762\u7684reconcileChildFibers \u8c03\u7528 reconcileSingleElement",id:"\u4e0a\u9762\u7684reconcilechildfibers-\u8c03\u7528-reconcilesingleelement",level:2},{value:"\u4e0a\u9762reconcileSingleElement \u8c03\u7528 createFiberFromElement",id:"\u4e0a\u9762reconcilesingleelement-\u8c03\u7528-createfiberfromelement",level:2},{value:"\u4e0a\u9762createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps",id:"\u4e0a\u9762createfiberfromelement-\u8c03\u7528-createfiberfromtypeandprops",level:2},{value:"\u4e0a\u9762\u7684 createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps",id:"\u4e0a\u9762\u7684-createfiberfromelement-\u8c03\u7528-createfiberfromtypeandprops",level:2},{value:"\u4e0a\u9762\u7684 createFiberFromTypeAndProps \u8c03\u7528 createFiber--&gt;FiberNode",id:"\u4e0a\u9762\u7684-createfiberfromtypeandprops-\u8c03\u7528-createfiber--fibernode",level:2},{value:"\u7b2c\u4e09\u6b21-beginWork-\u6b64\u65f6\u6784\u5efa code() \u751f\u6210\u7684\u8282\u70b9",id:"\u7b2c\u4e09\u6b21-beginwork-\u6b64\u65f6\u6784\u5efa-code-\u751f\u6210\u7684\u8282\u70b9",level:2}],d={toc:c},u="wrapper";function p(e){let{components:n,...i}=e;return(0,o.kt)(u,(0,t.Z)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"beginwork\u524d\u7f6e\u5de5\u4f5c"},"beginWork\u524d\u7f6e\u5de5\u4f5c"),(0,o.kt)("h3",{id:"beginwork\u4e4b\u524dworkinprogress\u6839\u8282\u70b9\u6784\u5efa"},"beginWork\u4e4b\u524dworkInProgress\u6839\u8282\u70b9\u6784\u5efa"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function createWorkInProgress(current, pendingProps) {\n    var workInProgress = current.alternate;\n    // \u533a\u5206\u662f\u5728mount\u65f6\u8fd8\u662f\u5728update\u65f6\n    if (workInProgress === null) {\n      // We use a double buffering pooling technique because we know that we'll\n      // only ever need at most two versions of a tree. We pool the \"other\" unused\n      // node that we're free to reuse. This is lazily created to avoid allocating\n      // extra objects for things that are never updated. It also allow us to\n      // reclaim the extra memory if needed.\n      console.log('==createWorkInProgress--\x3e,\u6ca1\u6709\u5c31\u521b\u5efa\u4e00\u4e2a')\n      workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n      console.log('==createWorkInProgress--\x3e,\u6ca1\u6709\u5c31\u521b\u5efa\u4e00\u4e2a\u8fd4\u56de\u503c', workInProgress)\n      debugger\n      workInProgress.elementType = current.elementType;\n      workInProgress.type = current.type;\n      workInProgress.stateNode = current.stateNode;\n\n      {\n        // DEV-only fields\n        workInProgress._debugSource = current._debugSource;\n        workInProgress._debugOwner = current._debugOwner;\n        workInProgress._debugHookTypes = current._debugHookTypes;\n      }\n      console.log('==createWorkInProgress--\x3e,workInProgress.alternate\u6307\u5b9a\u4e3acurrent')\n      workInProgress.alternate = current;\n      current.alternate = workInProgress;\n    } else {\n      // \u590d\u7528\u5c5e\u6027\n      workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n\n      workInProgress.type = current.type; // We already have an alternate.\n      // Reset the effect tag.\n\n      workInProgress.flags = NoFlags; // The effects are no longer valid.\n\n      workInProgress.subtreeFlags = NoFlags;\n      workInProgress.deletions = null;\n\n      {\n        // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n        // This prevents time from endlessly accumulating in new commits.\n        // This has the downside of resetting values for different priority renders,\n        // But works for yielding (the common case) and should support resuming.\n        workInProgress.actualDuration = 0;\n        workInProgress.actualStartTime = -1;\n      }\n    } // Reset all effects except static ones.\n    // Static effects are not specific to a render.\n\n\n    workInProgress.flags = current.flags & StaticMask;\n    // \u590d\u7528\u5c5e\u6027\n    workInProgress.childLanes = current.childLanes;\n    workInProgress.lanes = current.lanes;\n    workInProgress.child = current.child;\n    workInProgress.memoizedProps = current.memoizedProps;\n    workInProgress.memoizedState = current.memoizedState;\n    workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n    // it cannot be shared with the current fiber.\n\n    var currentDependencies = current.dependencies;\n    workInProgress.dependencies = currentDependencies === null ? null : {\n      lanes: currentDependencies.lanes,\n      firstContext: currentDependencies.firstContext\n    }; // These will be overridden during the parent's reconciliation\n\n    workInProgress.sibling = current.sibling;\n    workInProgress.index = current.index;\n    workInProgress.ref = current.ref;\n\n    {\n      workInProgress.selfBaseDuration = current.selfBaseDuration;\n      workInProgress.treeBaseDuration = current.treeBaseDuration;\n    }\n\n    {\n      workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n\n      switch (workInProgress.tag) {\n        case IndeterminateComponent:\n        case FunctionComponent:\n        case SimpleMemoComponent:\n          workInProgress.type = resolveFunctionForHotReloading(current.type);\n          break;\n\n        case ClassComponent:\n          workInProgress.type = resolveClassForHotReloading(current.type);\n          break;\n\n        case ForwardRef:\n          workInProgress.type = resolveForwardRefForHotReloading(current.type);\n          break;\n      }\n    }\n\n    return workInProgress;\n  }\n")),(0,o.kt)("h3",{id:"\u4e3aworkinprogress\u8d4b\u503c-renderrootsync--preparefreshstack"},"\u4e3aworkInProgress\u8d4b\u503c-renderRootSync--\x3eprepareFreshStack"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function renderRootSync(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n\n    }\n\n    workInProgressTransitions = getTransitionsForLanes();\n\n    console.log('workInProgress', workInProgress, root)\n    debugger\n    console.log('render\u8c03\u7528 prepareFreshStack\u524d',workInProgress)\n    prepareFreshStack(root, lanes);\n    console.log('workInProgress', workInProgress, root)\n    console.log('render\u8c03\u7528 prepareFreshStack\u540e',workInProgress)\n  }\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  var timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    var interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      var current = interruptedWork.alternate;\n      unwindInterruptedWork(current, interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  console.log('=render\u9636\u6bb5:prepareFreshStack=\u5904\u7406workInProgressRoot:workInProgressRoot = root')\n  workInProgressRoot = root;\n  var rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  enqueueInterleavedUpdates();\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n")),(0,o.kt)("h2",{id:"\u7b2c\u4e00\u6b21beginwork\u8c03\u7528updatehostroot\u8fdb\u884c\u521d\u59cb\u5316updatehostroot"},"\u7b2c\u4e00\u6b21beginWork\u8c03\u7528updateHostRoot\u8fdb\u884c\u521d\u59cb\u5316:updateHostRoot"),(0,o.kt)("p",null,"updateHostRoot--\x3ereconcileChildren(current, workInProgress, nextChildren, renderLanes)--\x3ereconcileChildren"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function beginWork(current, workInProgress, renderLanes) {\n    console.log('workInProgress', workInProgress, root)\n    debugger\n    workInProgress.lanes = NoLanes;\n    console.log('%c=beginWork()===start1-\u521d\u59cb\u5316', 'color:magenta', { getFiberName: getFiberName(workInProgress), current, renderLanes, workInProgress })\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        {\n          console.log('%c=beginWork()==end 2 mountIndeterminateComponent', 'color:magenta', workInProgress)\n          console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=\u8c03\u7528mountIndeterminateComponent`, 'color:blueviolet', workInProgress.type)\n          return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n      case HostRoot:\n        console.log('%c=beginWork()=end 6\u7b2c\u4e00\u6b21\u4f1a\u8d70\u8fd9\u91cc\u521d\u59cb\u5316workInProgress', 'color:magenta')\n        console.log('%c=beginWork()=end 6 updateHostRoot', 'color:magenta')\n        return updateHostRoot(current, workInProgress, renderLanes);\n    }\n  }\n")),(0,o.kt)("h3",{id:"\u9996\u6b21case\u8fdb\u5165hostroot-\u66f4\u65b0updatehostroot"},"\u9996\u6b21case\u8fdb\u5165HostRoot \u66f4\u65b0updateHostRoot\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  var nextState = workInProgress.memoizedState;\n  var root = workInProgress.stateNode;\n  // being called \"element\".\n\n\n  var nextChildren = nextState.element;\n\n  if (prevState.isDehydrated) {\n  } else {\n      // Root is not dehydrated. Either this is a client-only root, or it\n      // already hydrated.\n      resetHydrationState();\n\n      if (nextChildren === prevChildren) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      }\n\n      console.log('=reconcileChildren 9')\n      debugger\n      reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n      console.log('%c=updateHostRoot:\u6784\u5efa\u4e4b\u540eworkInProgress.child', 'color:black', { child })\n  }\n  console.log('%c=updateHostRoot:\u6700\u540e\u8fd4\u56deworkInProgress.child', 'color:black', workInProgress.child)\n\n  return workInProgress.child;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    console.log('%c=reconcileChildren mount', 'blueviolet');\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n    console.log('%c=reconcileChildren mount \u8fd4\u56de\u503cworkInProgress.child', 'blueviolet', workInProgress.child);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    console.log('%c=reconcileChildren update', 'yellow');\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n")),(0,o.kt)("h3",{id:"\u5f88\u957f\u7684\u51fd\u6570-childreconciler\u5b9a\u4e49\u4e86reconcilechildfibers\u7b49\u5f88\u591a\u51fd\u6570"},"\u5f88\u957f\u7684\u51fd\u6570-ChildReconciler\u5b9a\u4e49\u4e86reconcileChildFibers\u7b49\u5f88\u591a\u51fd\u6570"),(0,o.kt)("p",null,"Reconciler\u6a21\u5757\u7684\u6838\u5fc3\u90e8\u5206"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5bf9\u4e8e mount \u7684\u7ec4\u4ef6\uff0c\u4ed6\u4f1a\u521b\u5efa\u65b0\u7684\u5b50 Fiber \u8282\u70b9\uff1b"),(0,o.kt)("li",{parentName:"ul"},"\u5bf9\u4e8e update \u7684\u7ec4\u4ef6\uff0c\u4ed6\u4f1a\u5c06\u5f53\u524d\u7ec4\u4ef6\u4e0e\u8be5\u7ec4\u4ef6\u5728\u4e0a\u6b21\u66f4\u65b0\u65f6\u5bf9\u5e94\u7684 Fiber \u8282\u70b9\u6bd4\u8f83-Diff\u7b97\u6cd5\uff0c\u5c06\u6bd4\u8f83\u7684\u7ed3\u679c\u751f\u6210\u65b0 Fiber \u8282\u70b9\u3002")),(0,o.kt)("p",null,"\u4e0d\u8bba\u8d70\u54ea\u4e2a\u903b\u8f91\uff0c\u6700\u7ec8\u4ed6\u4f1a\u751f\u6210\u65b0\u7684\u5b50 Fiber \u8282\u70b9\u5e76\u8d4b\u503c\u7ed9workInProgress.child\uff0c\u4f5c\u4e3a\u672c\u6b21 beginWork \u8fd4\u56de\u503c\uff0c\u5e76\u4f5c\u4e3a\u4e0b\u6b21performUnitOfWork\u6267\u884c\u65f6workInProgress\u7684\u4f20\u53c2\u3002"),(0,o.kt)("p",null,"mountChildFibers\u4e0ereconcileChildFibers\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u7684\u903b\u8f91\u57fa\u672c\u4e00\u81f4\u3002\u552f\u4e00\u7684\u533a\u522b\u662f\uff1areconcileChildFibers \u4f1a\u4e3a\u751f\u6210\u7684 Fiber \u8282\u70b9\u5e26\u4e0aeffectTag\u5c5e\u6027\uff0c\u800c mountChildFibers \u4e0d\u4f1a\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var mountChildFibers = ChildReconciler(false);\n// \u8fd9\u4e2a\u4ee3\u7801\u5f88\u957f 1k,\u5b9a\u4e49\u5f88\u591a\u51fd\u6570reconcileChildFibers()\u662f\u5176\u4e2d\u4e00\u4e2a\nfunction ChildReconciler(shouldTrackSideEffects) {\n  // \u7701\u7565\u5f88\u591a\u51fd\u6570\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    // debugger\n    console.log('%c=reconcileChildFibers A', 'blueviolet');\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n")),(0,o.kt)("h2",{id:"\u7b2c\u4e8c\u6b21beginwork-casemountindeterminatecomponent-\u6267\u884ccode"},"\u7b2c\u4e8c\u6b21beginWork-case:mountIndeterminateComponent \u6267\u884ccode()"),(0,o.kt)("p",null,"\u6267\u884c\u5b8ccode()\u6b64\u65f6\u7684workInProgress.type \u624d\u6709\u503c;"),(0,o.kt)("p",null,"\u7b2c\u4e8c\u6b21beginWork\u8fdb\u5165case IndeterminateComponent \u6267\u884c mountIndeterminateComponent(),\u53ef\u89c1\u6df1\u5ea6\u904d\u5386\u4ece\u7236\u7ea7\u7ec4\u4ef6\u5f00\u59cb"),(0,o.kt)("p",null,"\u9996\u5148\u8981\u6ce8\u610f\u7684\u662f\uff0c\u867d\u7136 App \u662f\u4e00\u4e2a FunctionComponent\uff0c\u4f46\u662f\u5728 first paint \u7684\u65f6\u5019\uff0cReact \u5224\u65ad\u5176\u4e3a IndeterminateComponent"),(0,o.kt)("p",null,"\u5bf9\u4e8e FunctionComponent\uff0c\u5728\u7b2c\u4e00\u6b21\u8bc6\u522b\u7684\u65f6\u5019\u4f1a\u88ab\u8ba4\u4e3a\u662f IndeterminateComponent"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"switch (workInProgress.tag) {\n  case IndeterminateComponent:\n    {\n      console.log('%c=beginWork()==end 2 mountIndeterminateComponent', 'color:magenta')\n      console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=\u8c03\u7528mountIndeterminateComponent`, 'color:blueviolet')\n      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n    }\n  }\n")),(0,o.kt)("h3",{id:"\u91cd\u70b9-code\u51fd\u6570\u521d\u59cb\u5316\u5728renderwithhooks\u8fd9\u91cc\u6267\u884c"},"\u91cd\u70b9-code\u51fd\u6570\u521d\u59cb\u5316\u5728renderWithHooks\u8fd9\u91cc\u6267\u884c"),(0,o.kt)("p",null,"mountIndeterminateComponent "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u8c03\u7528  renderWithHooks \u751f\u6210 value"),(0,o.kt)("li",{parentName:"ul"},"\u6267\u884c reconcileChildren(null, workInProgress, value, renderLanes) \u53c2\u6570value")),(0,o.kt)("p",null,"\u5173\u952e\u7684\u51fd\u6570 renderWithHooks\uff1b\u800c\u5728 renderWithHooks \u4e2d\uff0c\u6211\u4eec\u4f1a\u6839\u636e\u7ec4\u4ef6\u5904\u4e8e\u4e0d\u540c\u7684\u72b6\u6001\uff0c\u7ed9 ReactCurrentDispatcher.current \u6302\u8f7d\u4e0d\u540c\u7684 dispatcher \u3002\u800c\u5728first paint \u65f6\uff0c\u6302\u8f7d\u7684\u662fHooksDispatcherOnMountInDEV"),(0,o.kt)("p",null,"HooksDispatcherOnMountInDEV \u91cc\u5c31\u662f\u7ec4\u4ef6 first paint \u7684\u65f6\u5019\u6240\u7528\u5230\u7684\u5404\u79cd hooks"),(0,o.kt)("h3",{id:"mountindeterminatecomponent"},"mountIndeterminateComponent()"),(0,o.kt)("p",null,"\u91cd\u70b9\u6267\u884creconcileChildren()\u5e76\u4f20\u5165value,\u5c31\u662fcode()\u8fd4\u56de\u7684\u6811\u7ed3\u6784"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  var props = workInProgress.pendingProps;\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var value;\n  var hasId;\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n    // \u7701\u7565\n    // debugger\n    console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=mountIndeterminateComponent\u8c03\u7528renderWithHooks 1`, 'color:blueviolet', { workInProgress, Component, props, context, renderLanes })\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=mountIndeterminateComponent\u8c03\u7528renderWithHooks \u8fd4\u56de\u503c`, 'color:blueviolet', { value })\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  }\n\n  // \u7701\u7565\n\n  if ( // Run these checks in production only if the flag is off.\n    // Eventually we'll delete this branch altogether.\n    typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      // \u7701\u7565\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    {\n\n      if (workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=mountIndeterminateComponent\u8c03\u7528renderWithHooks 2`, 'color:blueviolet')\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n\n    // debugger\n    console.log('%c=reconcileChildren 12:\u91cd\u70b9\uff0cmountIndeterminateComponent\u8c03\u7528reconcileChildren', 'color:red')\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n")),(0,o.kt)("h3",{id:"renderwithhooks-\u6267\u884ccode"},"renderWithHooks \u6267\u884ccode()"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n    // \u7701\u7565\uff1a\n    console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=renderWithHooks\u91cd\u70b9\uff0c\u8c03\u7528\u51fd\u6570\u7ec4\u4ef6\uff0c\u91cc\u9762\u6267\u884c\u5404\u79cd React Hook==start\u5e76\u8fd4\u56de ReactElement`, 'color:blueviolet', Component)\n    var children = Component(props, secondArg); // Check if there was a render phase update\n    console.log(`%c=\u63a2\u7a76\u521d\u59cb\u548chook=renderWithHooks\u91cd\u70b9,\u8fd4\u56de ReactElement==end`, 'color:blueviolet', { children })\n    // \u7701\u7565\uff1a\n    return children;\n}\n")),(0,o.kt)("p",null,"code()\u51fd\u6570\u548cReact.createElement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"return React.createElement(\n  'div',\n  { id: 'div1', className: 'c1' },\n  React.createElement(\n    'button',\n    { onClick: onClickText, className: 'btn' },\n    'Hello world,Click me'\n  ),\n  React.createElement(\n    'span',\n    null,\n    data\n  ),\n  showDiv && React.createElement(\n    'div',\n    null,\n    '\\u88AB\\u4F60\\u53D1\\u73B0\\u4E86'\n  ),\n  React.createElement(\n    'div',\n    { id: 'div2', className: 'c2' },\n    React.createElement(\n      'p',\n      null,\n      '\\u6D4B\\u8BD5\\u5B50\\u8282\\u70B9'\n    )\n  )\n);\n\nfunction createElement(type, config, children) {\n  // console.log('=development\u8c03\u7528createElement\u6784\u5efaAst\u6811:', { type, config, children })\n  console.log('%c=development\u8c03\u7528createElement-1:type', 'color:blueviolet', type, { config, children })\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n  }\n}\n")),(0,o.kt)("h2",{id:"\u6d41\u7a0b\u56fe-\u6784\u5efafiber\u6811\u6d41\u7a0b"},"\u6d41\u7a0b\u56fe-\u6784\u5efafiber\u6811\u6d41\u7a0b"),(0,o.kt)("p",null,"\u53ea\u8981\u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u5bf9\u8c61\u4e14\u5bf9\u8c61\u4e2d\u6709 render \u65b9\u6cd5\uff0c\u5c31\u8ba4\u4e3a\u662f ClassComponent\uff0c\u5426\u5219\u5c31\u662f FunctionComponent,\u4ecemountIndeterminateComponent\u5f00\u59cb,\u8fd9\u91cc\u4ee5\u51fd\u6570\u7ec4\u4ef6\u4e3a\u4f8b:"),(0,o.kt)("p",null,"\u63a5",(0,o.kt)("a",{parentName:"p",href:"./render%E9%98%B6%E6%AE%B5%E6%80%BB%E8%A7%88"},"render\u9636\u6bb5\u603b\u89c8:\u6d41\u7a0b\u56fe\u7684mountIndeterminateComponent\u51fd\u6570")),(0,o.kt)("mermaid",{value:'flowchart TD\nA1(mountIndeterminateComponent)\n\nA1--1--\x3eq1("value=renderWithHooks(null,workInProgress, Component<br/>\u8fd9\u4e2a\u51fd\u6570\u521d\u59cb\u5316hook\u51fd\u6570\u5e76\u6267\u884ccode\u51fd\u6570")\n\nq1--1hook\u76f8\u5173--\x3ehooks("ReactCurrentDispatcher$1.current=<br/>HooksDispatcherOnMountInDEV")\nq1--2\u6784\u5efavalue\u4f46\u4e0d\u662ffiber--\x3ecode("children=Component(props,secondArg)<br/>\u6267\u884cast\u751f\u6210\u7684code")\n\nA1--2value\u662frenderWithHooks\u8fd4\u56de--\x3eB1("reconcileChildren(null, workInProgress, value, renderLanes)")--value\u5c31\u662fnextChildren--\x3eB2("workInProgress.child = mountChildFibers<br/>(workInProgress, null, nextChildren, renderLanes)")--nextChildren\u5c31\u662fnewChild--\x3eB3("reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes)")\n\nB3--case:REACT_ELEMENT_TYPE--\x3eB5\n\nB5("return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild,")--\x3eB6("reconcileSingleElement(returnFiber, currentFirstChild, element, lanes)")\n\nB6--\x3eB8("_created4 = createFiberFromElement(element, returnFiber.mode")\n\nB8--\u51fd\u6570\u5b9a\u4e49--\x3eB9("createFiberFromElement(element, mode, lanes){<br/>fiber=createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes)<br/>return fiber\n")\n\nB9--\x3eB10("createFiberFromTypeAndProps(type, key, pendingProps")\n\nB10--\x3eB11("createFiber=function(tag, pendingProps, key, mode){<br/> return new FiberNode(tag, pendingProps, key, mode) }")\n\nB11--\u6784\u5efafiberNode--\x3eB12("FiberNode(tag, pendingProps, key, mode)")'}),(0,o.kt)("h2",{id:"reconcilechildren-\u91cd\u70b9\u51fd\u6570"},"reconcileChildren \u91cd\u70b9\u51fd\u6570"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    console.log('%c=reconcileChildren mount', 'blueviolet');\n    // \u5bf9\u4e8e mount \u7684\u7ec4\u4ef6\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n    console.log('%c=reconcileChildren mount \u8fd4\u56de\u503cworkInProgress.child', 'blueviolet', workInProgress.child);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    console.log('%c=reconcileChildren update', 'yellow');\n    // \u5bf9\u4e8e update \u7684\u7ec4\u4ef6\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762\u7684reconcilechildren-\u8c03\u7528-reconcilechildfibers"},"\u4e0a\u9762\u7684reconcileChildren \u8c03\u7528 reconcileChildFibers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    // debugger\n    console.log('%c=reconcileChildFibers A', 'blueviolet');\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          var payload = newChild._payload;\n          var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762\u7684reconcilechildfibers-\u8c03\u7528-reconcilesingleelement"},"\u4e0a\u9762\u7684reconcileChildFibers \u8c03\u7528 reconcileSingleElement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n  var key = element.key;\n  var child = currentFirstChild;\n\n  while (child !== null) {\n    // \u7701\u7565\n  }\n\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n    created.return = returnFiber;\n    return created;\n  } else {\n    console.log('%c=ChildReconciler \u4e2d\u8c03\u7528 createFiberFromElement 2', 'color:yellow');\n    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n\n    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n    _created4.return = returnFiber;\n    return _created4;\n  }\n}\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762reconcilesingleelement-\u8c03\u7528-createfiberfromelement"},"\u4e0a\u9762reconcileSingleElement \u8c03\u7528 createFiberFromElement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function createFiberFromElement(element, mode, lanes) {\n    var owner = null;\n\n    {\n      owner = element._owner;\n    }\n\n    var type = element.type;\n    var key = element.key;\n    var pendingProps = element.props;\n    console.log('%c=createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps--\x3ereturn fiber\uff1a', 'color:yellow')\n    var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n    console.log('%c=return fiber\uff1a', 'color:yellow', { fiber })\n    {\n      fiber._debugSource = element._source;\n      fiber._debugOwner = element._owner;\n    }\n\n    return fiber;\n  }\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762createfiberfromelement-\u8c03\u7528-createfiberfromtypeandprops"},"\u4e0a\u9762createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function createFiberFromElement(element, mode, lanes) {\n  var owner = null;\n\n  {\n    owner = element._owner;\n  }\n\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n  console.log('%c=createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps--\x3ereturn fiber\uff1a', 'color:yellow')\n  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n  console.log('%c=return fiber\uff1a', 'color:yellow', { fiber })\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762\u7684-createfiberfromelement-\u8c03\u7528-createfiberfromtypeandprops"},"\u4e0a\u9762\u7684 createFiberFromElement \u8c03\u7528 createFiberFromTypeAndProps"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function createFiberFromTypeAndProps(type, // React$ElementType\n    key, pendingProps, owner, mode, lanes) {\n    var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\n    var resolvedType = type;\n\n    if (typeof type === 'function') {\n      if (shouldConstruct$1(type)) {\n        fiberTag = ClassComponent;\n\n        {\n          resolvedType = resolveClassForHotReloading(resolvedType);\n        }\n      } else {\n        {\n          resolvedType = resolveFunctionForHotReloading(resolvedType);\n        }\n      }\n    } else if (typeof type === 'string') {\n      fiberTag = HostComponent;\n    } else {\n      getTag: switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n\n        case REACT_STRICT_MODE_TYPE:\n          fiberTag = Mode;\n          mode |= StrictLegacyMode;\n\n          if ((mode & ConcurrentMode) !== NoMode) {\n            // Strict effects should never run on legacy roots\n            mode |= StrictEffectsMode;\n          }\n\n          break;\n\n        case REACT_PROFILER_TYPE:\n          return createFiberFromProfiler(pendingProps, mode, lanes, key);\n\n        case REACT_SUSPENSE_TYPE:\n          return createFiberFromSuspense(pendingProps, mode, lanes, key);\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n\n        case REACT_OFFSCREEN_TYPE:\n          return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n\n        case REACT_LEGACY_HIDDEN_TYPE:\n\n        // eslint-disable-next-line no-fallthrough\n\n        case REACT_SCOPE_TYPE:\n\n        // eslint-disable-next-line no-fallthrough\n\n        case REACT_CACHE_TYPE:\n\n        // eslint-disable-next-line no-fallthrough\n\n        case REACT_TRACING_MARKER_TYPE:\n\n        // eslint-disable-next-line no-fallthrough\n\n        case REACT_DEBUG_TRACING_MODE_TYPE:\n\n        // eslint-disable-next-line no-fallthrough\n\n        default:\n          {\n            if (typeof type === 'object' && type !== null) {\n              switch (type.$$typeof) {\n                case REACT_PROVIDER_TYPE:\n                  fiberTag = ContextProvider;\n                  break getTag;\n\n                case REACT_CONTEXT_TYPE:\n                  // This is a consumer\n                  fiberTag = ContextConsumer;\n                  break getTag;\n\n                case REACT_FORWARD_REF_TYPE:\n                  fiberTag = ForwardRef;\n\n                  {\n                    resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                  }\n\n                  break getTag;\n\n                case REACT_MEMO_TYPE:\n                  fiberTag = MemoComponent;\n                  break getTag;\n\n                case REACT_LAZY_TYPE:\n                  fiberTag = LazyComponent;\n                  resolvedType = null;\n                  break getTag;\n              }\n            }\n\n            var info = '';\n\n            {\n              if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n              }\n\n              var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n            }\n\n            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n          }\n      }\n    }\n\n    console.log('%c=createFiberFromTypeAndProps \u4e2d\u8c03\u7528 createFiber return\uff1a', 'color:yellow')\n    var fiber = createFiber(fiberTag, pendingProps, key, mode);\n    console.log(`%c=retrun fiber`, 'color:grey', { fiber })\n    fiber.elementType = type;\n    fiber.type = resolvedType;\n    fiber.lanes = lanes;\n\n    {\n      fiber._debugOwner = owner;\n    }\n\n    return fiber;\n  }\n")),(0,o.kt)("h2",{id:"\u4e0a\u9762\u7684-createfiberfromtypeandprops-\u8c03\u7528-createfiber--fibernode"},"\u4e0a\u9762\u7684 createFiberFromTypeAndProps \u8c03\u7528 createFiber--\x3eFiberNode"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/huiruo/programming-tech-website/blob/main/programming-tech/React/00-react%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E4%BE%8B%E5%AD%90/%E4%BE%8B1-%E4%B8%BB%E8%A6%81%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B-render-commit-18.html"},"\u6d4b\u8bd5\u4f8b\u5b50")),(0,o.kt)("p",null,(0,o.kt)("img",{src:r(13283).Z,width:"1016",height:"881"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  var fiberNode = new FiberNode(tag, pendingProps, key, mode)\n  console.log('%c=createFiber\u4e2d\u8c03\u7528 new FiberNode-FiberNode\u8fd4\u56de\u503c:', 'color:grey', { fiberNode })\n  return fiberNode;\n};\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  console.log('%c=FiberNode,fiber\u7684\u534f\u8c03,\u6700\u5e95\u90e8\u5f00\u59cb\u8d4b\u503c===', 'color:yellow', { tag, ...pendingProps })\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null; // Fiber\n\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode; // Effects\n\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n  this.alternate = null;\n\n  {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n")),(0,o.kt)("h2",{id:"\u7b2c\u4e09\u6b21-beginwork-\u6b64\u65f6\u6784\u5efa-code-\u751f\u6210\u7684\u8282\u70b9"},"\u7b2c\u4e09\u6b21-beginWork-\u6b64\u65f6\u6784\u5efa code() \u751f\u6210\u7684\u8282\u70b9"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"      case HostComponent:\n        console.log(`%c=beginWork()=end 7 updateHostComponent$1,\u5373\u539f\u751f DOM \u7ec4\u4ef6\u5bf9\u5e94\u7684 Fiber\u8282\u70b9:`, 'color:magenta', { type: workInProgress.type })\n        return updateHostComponent$1(current, workInProgress, renderLanes);\n")),(0,o.kt)("p",null,"\u6b64\u65f6 workInProgress"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"actualDuration:0\nactualStartTime:-1\nalternate:null\nchild:null\nchildLanes:0\ndeletions: null\ndependencies: null\nelementType:\"div\"\nflags: 0\nindex : 0\nkey : null\nlanes : 0\nmemoizedProps:null\nmemoizedState:null\nmode:1\npendingProps:{id: 'div1', className: 'c1', children: Array(4)}\nref:null\nreturn:FiberNode {tag: 0, key: null, stateNode: null, elementType: \u0192, type: \u0192, \u2026}\nselfBaseDuration:0,\nsibling:null\nstateNode:null\nsubtreeFlags:0\ntag:5\ntreeBaseDuration:0\ntype:\"div\"\nupdateQueue:null\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function updateHostComponent$1(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef$1(current, workInProgress);\n  console.log('=reconcileChildren 11')\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n")))}p.isMDXComponent=!0},13283:(e,n,r)=>{r.d(n,{Z:()=>t});const t=r.p+"assets/images/\u4e3b\u8981\u6d4b\u8bd5\u5b9e\u4f8b-render-commit-18-fiber\u6784\u5efa-8f79e469a6109ef27a3dbb324c1a3827.png"}}]);