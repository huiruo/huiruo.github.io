<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-http-browser-promise/TCP-IP-握手" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">TCP-IP-握手 | Programming tech</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://huiruo.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://huiruo.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://huiruo.github.io/http-browser-promise/TCP-IP-握手"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="TCP-IP-握手 | Programming tech"><meta data-rh="true" name="description" content="1.TCP/IP协议分为4层"><meta data-rh="true" property="og:description" content="1.TCP/IP协议分为4层"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://huiruo.github.io/http-browser-promise/TCP-IP-握手"><link data-rh="true" rel="alternate" href="https://huiruo.github.io/http-browser-promise/TCP-IP-握手" hreflang="en"><link data-rh="true" rel="alternate" href="https://huiruo.github.io/http-browser-promise/TCP-IP-握手" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0527b3af.css">
<link rel="preload" href="/assets/js/runtime~main.22e0d712.js" as="script">
<link rel="preload" href="/assets/js/main.0d263467.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">programming-tech</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Main</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/huiruo/programming-tech-website/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently dark mode)" aria-label="Switch between dark and light mode (currently dark mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Readme</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/React概览">React概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Vue概览">Vue概览</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/React/编译阶段-jsx-ast">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/Vue/vue3/库-状态管理">Vue</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/JavaScript/继承/es6-extends">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/html-css/requestAnimationFrame/requestAnimationFrame-是宏任务吗">html-css</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/webGL/webgl与canvas-性能-动画区别">webGL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/http-browser-promise/promise/promise基础">http-browser-promise</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/http-browser-promise/promise/promise基础">promise</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/http-browser-promise/防抖节流/防抖">防抖节流</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/event-loop">event loop</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/浏览器4个进程之渲染进程-浏览器内核之渲染引擎和JS引擎-V8引擎执行JS">浏览器4个进程之渲染进程-浏览器内核之渲染引擎和JS引擎-V8引擎执行JS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/浏览器对事件的处理-1冒泡-2捕获">浏览器对事件的处理-1冒泡-2捕获</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/web安全漏洞-XSS和CSRF">安全-web有两大类漏洞-XSS和CSRF</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/辅-浏览器兼容性">浏览器兼容性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/题目">题目</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/浏览器请求-渲染的流程">浏览器请求-渲染的流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/浏览器缓存">浏览器缓存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/service-worker">service-worker</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/http1.1-报文">http1.1-报文</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/reflow-repaint">reflow-repaint</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/http-browser-promise/TCP-IP-握手">TCP-IP-握手</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/https-加密方式">https-加密方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/跨域-反向代理-正向代理">跨域-反向代理-正向代理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/辅-DNS查询过程-DNS污染-IP封锁">DNS查询过程-DNS污染-IP封锁</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/鉴权-Token和JWT-cookie-session">鉴权-Token和JWT-cookie-session</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/http-和js-stream">http-和js-stream</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-browser-promise/辅-vpn-vps-Proxy以及shadowsocks之间的联系和区别">vpn-vps-Proxy以及shadowsocks之间的联系和区别</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/http-browser-promise/WebSocket-Socks5-shadowsocks/00-1-WebSocket和http异同">WebSocket-Socks5-shadowsocks</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/parsing-interpretation-compilation/模块化/esm">parsing-interpretation-compilation</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/webpack-AST-Babel/AST">webpack-AST-Babel</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/SSR-Nodejs/react-ssr渲染">SSR-Nodejs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/web-optimization/总结">web optimization</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/C++-V8/v8/v8基础">C++-V8</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/backend/nextjs/">backend</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docker/Docker基础">docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/design-patterns/">design patterns</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/regular-string/正则-基础">regular-string</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/build-monorepo-turbopack/monorepo">monorepo-turbopack</a></div></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">http-browser-promise</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">TCP-IP-握手</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>TCP-IP-握手</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1tcpip协议分为4层">1.TCP/IP协议分为4层<a href="#1tcpip协议分为4层" class="hash-link" aria-label="Direct link to 1.TCP/IP协议分为4层" title="Direct link to 1.TCP/IP协议分为4层">​</a></h2><p>TCP/IP协议栈通常被划分为四个主要的网络协议层：</p><ol><li>应用层（Application Layer）： 这是协议栈的顶层，包含了与应用程序通信相关的协议和服务。应用层协议处理数据的高级表示，包括应用程序间的通信、数据格式、消息交换、安全等。一些常见的应用层协议包括HTTP、FTP、SMTP、DNS等。</li><li>传输层（Transport Layer）： 传输层提供端到端的数据传输服务，负责数据分段、重组和错误恢复。最常见的传输层协议是TCP（传输控制协议）和UDP（用户数据报协议）。TCP提供可靠的、面向连接的通信，而UDP提供不可靠的、面向数据包的通信。</li><li>网络层（Network Layer）： 网络层负责数据包的路由和转发，以及在不同网络之间的数据传输。它定义了数据包的寻址和路由规则，使数据能够跨越不同的网络传输。Internet协议（IP）是最常见的网络层协议，负责在全球互联网上进行数据包路由。</li><li>链路层（Link Layer）： 链路层负责物理传输媒介（例如以太网、Wi-Fi、蓝牙等）上的数据帧传输。它包括数据帧的封装、地址解析、物理层寻址和错误检测。在不同的物理网络中，链路层协议可能会有所不同。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-1应用层">1-1.应用层<a href="#1-1应用层" class="hash-link" aria-label="Direct link to 1-1.应用层" title="Direct link to 1-1.应用层">​</a></h3><p>在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议：</p><ul><li>文件传输协议FTP</li><li>电子邮件传输协议SMTP</li><li>域名系统服务DNS</li><li>网络新闻传输协议NNTP和HTTP协议等</li><li>HTTP 协议也处于该层</li></ul><p>应用层决定了向用户提供应用服务时通信的活动。
应用层负责处理特定的应用程序细节。 </p><p>DNS服务是和http协议在应用层的协议，dns提供域名到ip地址之间的解析服务</p><p>用户通常通过使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。所有需要dns协议提供通过域名查找ip地址，或逆向从ip地址查找域名服务。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-2传输层-tcpudp-协议tcp位于传输层提供可靠的字节流服务">1-2:传输层-TCP/UDP 协议:TCP位于传输层，提供可靠的字节流服务<a href="#1-2传输层-tcpudp-协议tcp位于传输层提供可靠的字节流服务" class="hash-link" aria-label="Direct link to 1-2:传输层-TCP/UDP 协议:TCP位于传输层，提供可靠的字节流服务" title="Direct link to 1-2:传输层-TCP/UDP 协议:TCP位于传输层，提供可靠的字节流服务">​</a></h3><p>所谓的字节流服务：为方便传输，将大块数据分割成以报文段 为单位的数据包进行管理。</p><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。
实例：</p><p>用HTTP举例来说明，客户端：</p><ol><li>首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li><li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，</li><li>并在各个报文上打上标记序号及端口号后转发给网络层</li><li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。</li></ol><p>服务端：
接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。</p><p>解析：</p><blockquote><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p></blockquote><blockquote><p>可靠的传输服务：能够把数据准确可靠传给对方。</p></blockquote><p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。</p><p>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p><p>TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。</p><p>UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-2-1如何理解tcp">1-2-1.如何理解TCP?<a href="#1-2-1如何理解tcp" class="hash-link" aria-label="Direct link to 1-2-1.如何理解TCP?" title="Direct link to 1-2-1.如何理解TCP?">​</a></h3><p>1.应用数据块如何在浩瀚的互联网准确无误找到目的地？
IP协议:在应用数据块的外层写上目的地IP地址，使得应用数据块可以找到目的地，这样就解决问题1。
2.服务器回应数据块如何在浩瀚的互联网准确无误地返回？
IP协议还会在应用数据块的外层写上源IP地址，使得服务器回应数据块返回源主机，这样就解决问题2。
3.应用数据块在到达目的地之前丢失了，如何处理？
4.服务器回应数据块旅途中丢失了，如何处理？</p><p>IP协议解决1和2问题点基于</p><ul><li>底层物理网络的连通性是IP能否正常工作的前提</li><li>IP路由表在全球路由器里完成了同步</li></ul><p><strong>即使有了这两个前提条件，也不能100%保证IP报文能够到达目的地！</strong><br></p><p>信号传输过程失真造成丢包、网络发生拥堵而丢包</p><p>我们还需要一个协议，这个协议需要有以下特质：
1.当丢包发生时，能够自动修复丢包，而无需人的手动干预
2.能够智能感知网络的拥堵情况，网络空闲时，尽最大速率发包；网络拥堵时，降低速率发包，不给互联网添堵</p><p>TCP协议也不是什么大神，不过是一个任劳任怨的流量调度员。说到底它就有一个本事：
<strong>确认机制！</strong></p><p>凭着这个看家本领，TCP可以保证应用数据的可靠传输。
TCP会对发出的数据包（以下简称包裹）进行编号，如同快递的快递单号一样。对方TCP收到包裹，会回复一个确认消息，确认收到了该编号的包裹了</p><p>有同学会说，确认机制可以理解，TCP发数据就发数据，但为何TCP发数据之前需要连接？</p><p>在互联网上可以找到各种各样的解释，而我的观点是：</p><p>双方通过TCP连接，分享彼此的应用数据块第一个字节的原点序号。</p><p>如果TCP没有提前分享，接收方不知道接收的数据是否是第一个包。</p><p>如果不是第一个包，接收方的TCP却将该数据包提交给应用程序，应用程序压根无法理解。</p><p>应用程序以为是第一个包，其实并不是，应用程序的小翻译（HTTP/FTP/SMTP）瞬间懵逼，风雨中瑟瑟发抖。。。</p><p>为何无法理解?
分享了原点序列号，即使第二个、第三个数据包先到达目的地，而第一个数据包姗姗来迟的情况，接收方的TCP可以耐心等待第一个数据包的到来，然后按序将数据包提交给应用程序。这样应用程序的小翻译就会秒懂。。。</p><p>有了TCP协议的帮助，即使老王的网线拔掉了一段时间，稍后再插入，恢复了网络连通性，老王中断的文件下载任务可以继续工作，而无需老王重新下载。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-3网络层-ip协议负责传输的ip协议">1-3:网络层-IP协议:负责传输的IP协议<a href="#1-3网络层-ip协议负责传输的ip协议" class="hash-link" aria-label="Direct link to 1-3:网络层-IP协议:负责传输的IP协议" title="Direct link to 1-3:网络层-IP协议:负责传输的IP协议">​</a></h3><p>传输数据的时候只使用 TCP/IP 协议(传输层)，如果没有应用层来识别数据内容，传输后的协议都是无用的。</p><p><img loading="lazy" alt="Alt text" src="/assets/images/图1http分层-28567ed707d79b36fab01104730d2a16.jpg" width="600" height="450" class="img_ev3q">
<img loading="lazy" src="/assets/images/osi网络七层和tcpIp四层-3ec0fcf29871ec546a2503db8f455e98.png" width="830" height="446" class="img_ev3q">
<img loading="lazy" alt="Alt text" src="/assets/images/图2物数网传会表应-7e8857cc791c08fb7b843e85a3303b30.jpg" width="750" height="495" class="img_ev3q"></p><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</p><p>也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）</p><p>IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</p><p>ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</p><p>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p><p>按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎 所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就 是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能 有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。</p><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址。
IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。
##使用 ARP 协议凭借 MAC 地址进行通信。</p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-4数据链路层">1-4.数据链路层<a href="#1-4数据链路层" class="hash-link" aria-label="Direct link to 1-4.数据链路层" title="Direct link to 1-4.数据链路层">​</a></h3><p>物理层的作用就是定义怎么用物理信号来表示数据。
将数据最终编码为用0、1标识的比特流，然后传输。</p><p>比如为什么网线是8根小线组成的而不是6根，wifi的电磁波频率为什么是2.4G和5G而不是别的，这些都是ieee（电气和电子工程师协会）规定的标准</p><p>最后一层了，经过上述拆件、打完各层标签后的6个数据帧，物理层将他们翻译文6段0、1表示的比特流，然后通过光纤、铜缆进行传输。</p><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内</p><p>也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2一个http请求的分层解析流程">2.一个HTTP请求的分层解析流程<a href="#2一个http请求的分层解析流程" class="hash-link" aria-label="Direct link to 2.一个HTTP请求的分层解析流程" title="Direct link to 2.一个HTTP请求的分层解析流程">​</a></h2><p>通过一个 HTTP 请求看一下不同层次之间是如何工作的：
<img loading="lazy" alt="Alt text" src="/assets/images/图5-HTTP请求的分层解析流程-d4f59bb13a12c0dbfefe4e9bdd033a76.png" width="1102" height="536" class="img_ev3q"></p><p>我们的服务器上部署了一个静态页面(图片又上角黄色的部分)，通过 Nginx 部署在我们的公网上面，现在我们通过浏览器来进行访问，在浏览器中输入域名，点下回车之后它们是如何工作的呢？</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-1获取域名">2-1.获取域名：<a href="#2-1获取域名" class="hash-link" aria-label="Direct link to 2-1.获取域名：" title="Direct link to 2-1.获取域名：">​</a></h3><p>浏览器先会去解析域名，因为在客户端 C 与服务端 S 进行数据交互的时候，它是不认域名的，认的是 ip 地址，所以浏览器先会解析域名，然后去看下浏览器中有没有域名对应的 DNS 的相关信息的缓存，有的话我们就能从中拿到服务端 S 的 ip 地址，没有的话，会去本地的 host 文件里看有没有配置，没有配置的话，会发起一个 DNS 的请求，获取服务器的 ip 地址(DNS 也是一台服务器，也有自己的 ip 地址，通常是配置在操作系统上的)。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-2获取服务器-ip-地址过程">2-2.获取服务器 IP 地址过程：<a href="#2-2获取服务器-ip-地址过程" class="hash-link" aria-label="Direct link to 2-2.获取服务器 IP 地址过程：" title="Direct link to 2-2.获取服务器 IP 地址过程：">​</a></h3><p>应用层------&gt;传输层</p><blockquote><p>这时应用层会构造一个 DNS 请求报文，然后应用层会调用传输层的一个接口，因为 DNS 使用 UDP 来进行数据的传输，所以应用层会调用传输层的 UDP 相关的一个协议，实现数据的传输。</p></blockquote><p>说白了就是应用层会调用传输层的 API,传输层会在 DNS 请求报文的基础上加一个 UDP 的请求头。</p><p>传输层----&gt;网络层----&gt;数据链路层</p><p>然后传输层会把数据交给网络层，网络层同样的会在 UDP 的请求报文的基础上再加一个 IP 的请求头，网络层再把 IP 请求报文交给数据链路层，</p><p>  数据链路层-----&gt;然后通过物理层传出去，通常传到路由器上面
数据链路层会实现一个二层的寻址，这时它会把自己的 make 头加上去，并且会把对应的请求报文应该要去交给下一个机器的 make 地址也加上去(会通过网络层的 ARP 协议去找到，ARP 会发送 ARP 的请求去看下 IP 地址对应的 make 地址是多少，拿到之后会交给数据链路层)，然后通过物理层传出去，通常传到路由器上面。</p><font color="red">路由器返回域名对应的IP地址(拿到后层层往上传到应用层)</font><p>路由器是一个三层的设备，最开始会通过物理层来进行连接，之后物理层把数据交给数据链路层，链路层会看下 make 地址是不是给我的，是给我的就解析，不是就丢弃，解析完后，数据报文在往上面去传输到网络层，网络层会去看下这个数据应该传到下一个路由器的地址是多少，这个时候它会通过运营商的网络接口传到运营商的路由器上面，</p><p>运营商这边就比较复杂，运营商会有自己的 DNS 服务器，如果电脑配置的是运营商的 DNS 的话，会直接去运营商的 DNS 服务器上去找对应的域名，
这个时候就会拿到对应的 ip 地址，然后开始一个层层的原路返回，直到应用层拿到了返回的报文，也就是拿到了域名对应的 IP 地址。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-3这时应用层就会进行-http-请求报文的发送这时-http-会干什么呢">2-3.这时应用层就会进行 HTTP 请求报文的发送，这时 HTTP 会干什么呢？<a href="#2-3这时应用层就会进行-http-请求报文的发送这时-http-会干什么呢" class="hash-link" aria-label="Direct link to 2-3.这时应用层就会进行 HTTP 请求报文的发送，这时 HTTP 会干什么呢？" title="Direct link to 2-3.这时应用层就会进行 HTTP 请求报文的发送，这时 HTTP 会干什么呢？">​</a></h3><p>应用层------&gt;传输层</p><blockquote><p>同样的它会去调用传输层的协议,因为 HTTP 是基于 TCP 协议来实现的，所以在调用传输协议的时候，传的是 TCP 的一些参数，</p></blockquote><p>传输层----&gt;网络层----&gt;数据链路层---&gt;然后通过物理层传出去，通常传到路由器进行传输</p><p>TCP 会调网络层的 IP 协议，IP 协议会加 IP 头，然后数据链路层会加上 make 头，和刚才 UDP 协议是一样的，会通过物理层和路由器进行数据的传输，</p><p>这一次携带的是 IP 地址，所以不用访问运营商的 DNS 服务器，而是运营商根据 IP 地址把数据报文传输给目标服务器的运营商，运营商之前有专线进行连接，所以数据到达了服务器的网络环境下，仍然逐层解析，物理层发往数据链路层，链路层判断数据是不是给自己的，是的话就进行解析，链路层发往网络层，判断网络的 IP 地址是不是自己，是的话进行解析，发往传输层，解析 TCP 的端口比如 80，传输层会把请求报文交给应用层应用程序，如果部署的是 Nginx 服务器的话，默认去找 80 端口对应的应用程序，应用层解析报文，构造一个 HTTP 的响应报文，逐层返回到客户端 C。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3三次握手使用tcp协议建立连接需要经过三次握手">3.三次握手:使用TCP协议建立连接需要经过三次握手<a href="#3三次握手使用tcp协议建立连接需要经过三次握手" class="hash-link" aria-label="Direct link to 3.三次握手:使用TCP协议建立连接需要经过三次握手" title="Direct link to 3.三次握手:使用TCP协议建立连接需要经过三次握手">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-1三次握手">3-1.三次握手<a href="#3-1三次握手" class="hash-link" aria-label="Direct link to 3-1.三次握手" title="Direct link to 3-1.三次握手">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">A--SYN请求--&gt;B</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A&lt;--确认--B</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A&lt;--请求--B   合并</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A--确认--&gt;B   确认非过期开始通知服务端准备接收http</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>TCP（传输控制协议）是一种可靠的、面向连接的协议，用于在网络上可靠地传输数据。<code>三次握手是TCP协议用于建立连接的过程，确保通信的双方都愿意建立连接并同步其初始序列号。</code>这个过程通常涉及客户端和服务器之间的通信。以下是TCP三次握手的详细步骤：</p><ol><li><p>客户端向服务器发送请求建立连接的请求：在通信开始时，客户端（浏览器或其他应用程序）将向服务器发送一个特殊的TCP报文，其中包含一个标志位（SYN），表示请求建立连接。此报文还包括客户端的初始序列号（一个随机数），以便服务器知道从何处开始传输数据。</p></li><li><p>服务器确认请求并返回应答：如果服务器愿意建立连接，它将发送一个带有SYN和ACK（确认）标志的报文，表示它接受连接请求。这个报文也包括服务器的初始序列号。服务器还需要将对客户端请求的确认号设置为客户端的初始序列号加1，以同步序列号。</p></li><li><p>客户端发送最后的确认：客户端接收到服务器的确认后，会发送一个带有ACK标志的报文，确认服务器的应答。这个报文的确认号会设置为服务器的初始序列号加1，以同步序列号。此时，客户端和服务器之间的连接已建立，可以开始安全地传输数据。</p></li></ol><p>完成这个三次握手过程后，客户端和服务器之间的TCP连接被建立，它们可以在这个连接上进行数据交换。这个过程确保了双方都知道连接已建立，并且初始化了用于数据传输的序列号。一旦连接建立，HTTP协议就可以在此TCP连接上进行HTTP请求和响应。注意，三次握手仅在连接初始化时发生，以后的数据传输不需要重复建立连接。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4为什么三次握手">4.为什么三次握手<a href="#4为什么三次握手" class="hash-link" aria-label="Direct link to 4.为什么三次握手" title="Direct link to 4.为什么三次握手">​</a></h2><p>三次握手是TCP协议用于建立连接的关键过程，它有几个重要的目的和原因：</p><ol><li><p>双向确认：通过三次握手，双方都可以确认对方的意愿和准备就绪。客户端首先发出连接请求（第一个握手），服务器接受请求并表示同意（第二个握手），然后客户端确认服务器的接受（第三个握手）。这种双向确认确保了双方都知道连接已建立。</p></li><li><p>初始化序列号：每个TCP连接都有一个初始的序列号，用于标识数据包的顺序和可靠性。在三次握手过程中，客户端和服务器都会交换各自的初始序列号，从而确保双方知道如何编排和解析数据包。这有助于确保数据在传输过程中的正确性和可靠性。</p></li><li><p>防止连接重用：在三次握手之后，每个TCP连接都有一个唯一的标识符（包括初始序列号），因此不同的连接可以并存。这有助于确保连接不会混淆或重用，从而保护了数据的隔离性和可靠性。</p></li><li><p>避免过早打开连接：三次握手可以防止失效的连接请求打开。例如，如果客户端发送了连接请求，但因某种原因未能到达服务器，服务器会在未经确认的情况下打开连接，这可能会导致资源浪费和潜在的安全问题。通过三次握手，服务器可以确保客户端的连接请求是有效的。</p></li></ol><blockquote><p>总之，三次握手是为了建立可靠的TCP连接，确保双方都知道连接已建立，初始化序列号，避免不必要的连接打开，并保护连接的隔离性。这些特性对于确保网络通信的可靠性和正确性至关重要。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-1主要原因通过三次握手才能阻止重复历史连接的初始化">4-1.主要原因:通过三次握手才能阻止重复历史连接的初始化<a href="#4-1主要原因通过三次握手才能阻止重复历史连接的初始化" class="hash-link" aria-label="Direct link to 4-1.主要原因:通过三次握手才能阻止重复历史连接的初始化" title="Direct link to 4-1.主要原因:通过三次握手才能阻止重复历史连接的初始化">​</a></h3><p>这是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因。</p><p>RFC 793 - Transmission Control Protocol 其实就指出了 TCP 连接使用三次握手的首要原因:</p><blockquote><p>为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p></blockquote><p><code>连接的定义，我们才能去尝试回答为什么 TCP 建立连接需要三次握手</code>
RFC 793 - Transmission Control Protocol 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。</p><p>建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的<code>序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。 TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：</code></p><ul><li>如果当前连接是历史连接，即 SEQ 过期或者超时，<font color="red">那么发送方就会直接发送 RST 控制消息中止这一次连接；</font></li><li>如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；</li></ul><p>使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="扩展如果采用两次">扩展：如果采用两次<a href="#扩展如果采用两次" class="hash-link" aria-label="Direct link to 扩展：如果采用两次" title="Direct link to 扩展：如果采用两次">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">假如两次握手：</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A--请求--&gt;B</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A&lt;--确认--B</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A&lt;--请求--B    合并</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>采用两次那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求,造成服务端资源一直在等待；</p><p>如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果TCP建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。此时假设的是不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则导致服务端一致等待客户端发送数据，浪费资源。</p><p>两次握手没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。
目的：为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-2通过三次握手才能对通信双方的初始序列号进行初始化">4-2.通过三次握手才能对通信双方的初始序列号进行初始化；<a href="#4-2通过三次握手才能对通信双方的初始序列号进行初始化" class="hash-link" aria-label="Direct link to 4-2.通过三次握手才能对通信双方的初始序列号进行初始化；" title="Direct link to 4-2.通过三次握手才能对通信双方的初始序列号进行初始化；">​</a></h3><p>三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱。</p><p>原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p><ul><li>数据包被发送方多次发送造成数据的重复；</li><li>数据包在传输的过程中被路由或者其他节点丢失；</li><li>数据包到达接收方可能无法按照发送顺序；</li></ul><p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p><ul><li>接收方可以通过序列号对重复的数据包进行去重；</li><li>发送方会在对应数据包未被 ACK 时进行重复发送；</li><li>接收方可以根据数据包的序列号对它们进行重新排序；</li></ul><blockquote><p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="扩展syn攻击是什么三次握手过程中可以携带数据吗">扩展：SYN攻击是什么？三次握手过程中可以携带数据吗？<a href="#扩展syn攻击是什么三次握手过程中可以携带数据吗" class="hash-link" aria-label="Direct link to 扩展：SYN攻击是什么？三次握手过程中可以携带数据吗？" title="Direct link to 扩展：SYN攻击是什么？三次握手过程中可以携带数据吗？">​</a></h3><p><code>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</code>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据
为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没问题。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="四次挥手">四次挥手<a href="#四次挥手" class="hash-link" aria-label="Direct link to 四次挥手" title="Direct link to 四次挥手">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="四次挥手-1">四次挥手<a href="#四次挥手-1" class="hash-link" aria-label="Direct link to 四次挥手" title="Direct link to 四次挥手">​</a></h3><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<code>半关闭</code>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<code>连接释放报文段</code>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<code>确认报文段</code>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<code>连接释放报文段</code>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<code>确认报文段</code>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img loading="lazy" src="/assets/images/四次挥手-1a1404b9477318254dac73f402cc7ec3.png" width="803" height="398" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="挥手为什么需要四次">挥手为什么需要四次？<a href="#挥手为什么需要四次" class="hash-link" aria-label="Direct link to 挥手为什么需要四次？" title="Direct link to 挥手为什么需要四次？">​</a></h3><p>tcp是全双工通信，服务端和客服端都能发送和接收数据。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">第1次挥手</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">第2次挥手</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">第3次握手</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">第4次挥手</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不是3次挥手">为什么不是3次挥手<a href="#为什么不是3次挥手" class="hash-link" aria-label="Direct link to 为什么不是3次挥手" title="Direct link to 为什么不是3次挥手">​</a></h3><p>在客服端第1次挥手时，服务端可能还在发送数据。</p><p>所以第2次挥手和第3次挥手不能合并。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">A:我没有数据发给你了，你如果还有数据发给我，就继续发吧</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">B：我知道了，我发完了告诉你</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">B：我也发完了，你可以关了 </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">A：我知道了，我断开了，可以确认断开了</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">1. 主动方发送`Fin=1， Ack=Z， Seq= X`报文</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2. 被动方发送`ACK=X+1， Seq=Z`报文</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3. 被动方发送`Fin=1， ACK=X， Seq=Y`报文</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">4. 主动方发送`ACK=Y， Seq=X`报文</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，&quot;你发的FIN报文我收到了&quot;。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="osi和tcpip不一样一个是理论模型一个是实际应用模型">osi和tcp/ip不一样，一个是理论模型一个是实际应用模型<a href="#osi和tcpip不一样一个是理论模型一个是实际应用模型" class="hash-link" aria-label="Direct link to osi和tcp/ip不一样，一个是理论模型一个是实际应用模型" title="Direct link to osi和tcp/ip不一样，一个是理论模型一个是实际应用模型">​</a></h2><p>共同点:</p><ol><li>OSI参考模型和TCP/IP参考模型都采用了层次结构的概念</li><li>都能够提供面向连接和无连接两种通信服务机制
不同点:</li><li>OSI采用的七层模型，而TCP/IP是四层结构</li><li>OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络</li><li>TCP/IP参考模型的网络接口层并不是真正的一层；OSI参考模型的缺点是层次过多，划分意义不大但增加了复杂性</li><li>OSI参考模型虽然被看好，由于没把握好时机，技术不成熟，实现困难；相反，TCP/IP参考模型虽然有许多不尽人意的地方，但还是比较成功的</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/huiruo/programming-tech-website/edit/main/programming-tech/http-browser-promise/TCP-IP-握手.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/http-browser-promise/reflow-repaint"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">reflow-repaint</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/http-browser-promise/https-加密方式"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">https-加密方式</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1tcpip协议分为4层" class="table-of-contents__link toc-highlight">1.TCP/IP协议分为4层</a><ul><li><a href="#1-1应用层" class="table-of-contents__link toc-highlight">1-1.应用层</a></li><li><a href="#1-2传输层-tcpudp-协议tcp位于传输层提供可靠的字节流服务" class="table-of-contents__link toc-highlight">1-2:传输层-TCP/UDP 协议:TCP位于传输层，提供可靠的字节流服务</a></li><li><a href="#1-2-1如何理解tcp" class="table-of-contents__link toc-highlight">1-2-1.如何理解TCP?</a></li><li><a href="#1-3网络层-ip协议负责传输的ip协议" class="table-of-contents__link toc-highlight">1-3:网络层-IP协议:负责传输的IP协议</a></li><li><a href="#1-4数据链路层" class="table-of-contents__link toc-highlight">1-4.数据链路层</a></li></ul></li><li><a href="#2一个http请求的分层解析流程" class="table-of-contents__link toc-highlight">2.一个HTTP请求的分层解析流程</a><ul><li><a href="#2-1获取域名" class="table-of-contents__link toc-highlight">2-1.获取域名：</a></li><li><a href="#2-2获取服务器-ip-地址过程" class="table-of-contents__link toc-highlight">2-2.获取服务器 IP 地址过程：</a></li><li><a href="#2-3这时应用层就会进行-http-请求报文的发送这时-http-会干什么呢" class="table-of-contents__link toc-highlight">2-3.这时应用层就会进行 HTTP 请求报文的发送，这时 HTTP 会干什么呢？</a></li></ul></li><li><a href="#3三次握手使用tcp协议建立连接需要经过三次握手" class="table-of-contents__link toc-highlight">3.三次握手:使用TCP协议建立连接需要经过三次握手</a><ul><li><a href="#3-1三次握手" class="table-of-contents__link toc-highlight">3-1.三次握手</a></li></ul></li><li><a href="#4为什么三次握手" class="table-of-contents__link toc-highlight">4.为什么三次握手</a><ul><li><a href="#4-1主要原因通过三次握手才能阻止重复历史连接的初始化" class="table-of-contents__link toc-highlight">4-1.主要原因:通过三次握手才能阻止重复历史连接的初始化</a></li><li><a href="#扩展如果采用两次" class="table-of-contents__link toc-highlight">扩展：如果采用两次</a></li><li><a href="#4-2通过三次握手才能对通信双方的初始序列号进行初始化" class="table-of-contents__link toc-highlight">4-2.通过三次握手才能对通信双方的初始序列号进行初始化；</a></li><li><a href="#扩展syn攻击是什么三次握手过程中可以携带数据吗" class="table-of-contents__link toc-highlight">扩展：SYN攻击是什么？三次握手过程中可以携带数据吗？</a></li></ul></li><li><a href="#四次挥手" class="table-of-contents__link toc-highlight">四次挥手</a><ul><li><a href="#四次挥手-1" class="table-of-contents__link toc-highlight">四次挥手</a></li><li><a href="#挥手为什么需要四次" class="table-of-contents__link toc-highlight">挥手为什么需要四次？</a></li><li><a href="#为什么不是3次挥手" class="table-of-contents__link toc-highlight">为什么不是3次挥手</a></li></ul></li><li><a href="#osi和tcpip不一样一个是理论模型一个是实际应用模型" class="table-of-contents__link toc-highlight">osi和tcp/ip不一样，一个是理论模型一个是实际应用模型</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.22e0d712.js"></script>
<script src="/assets/js/main.0d263467.js"></script>
</body>
</html>