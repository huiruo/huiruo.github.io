<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-http-浏览器缓存/浏览器请求-渲染的流程-回流重绘">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">浏览器请求-渲染的流程-回流重绘 | Programming tech</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://huiruo.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://huiruo.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://huiruo.github.io/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="浏览器请求-渲染的流程-回流重绘 | Programming tech"><meta data-rh="true" name="description" content="简要过程:"><meta data-rh="true" property="og:description" content="简要过程:"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://huiruo.github.io/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘"><link data-rh="true" rel="alternate" href="https://huiruo.github.io/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘" hreflang="en"><link data-rh="true" rel="alternate" href="https://huiruo.github.io/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.d2b88536.css">
<link rel="preload" href="/assets/js/runtime~main.654f7f82.js" as="script">
<link rel="preload" href="/assets/js/main.0a662770.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">programming-tech</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/start">Main</a><a class="navbar__item navbar__link" href="/structure-algorithm/">Structure Algorithm</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/huiruo/programming-tech-website/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently dark mode)" aria-label="Switch between dark and light mode (currently dark mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/start">start</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/react-vue异同-react">react-vue异同-react</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/react-vue异同-vue">react-vue异同-vue</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/React/jsx-ast-render阶段">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/Vue/vue3/库-状态管理">Vue</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/JavaScript/keys-hasOwnProperty-defineProperty-forin">JavaScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/category/解析-解释-编译-事件循环-promise-安全">解析-解释-编译-事件循环-promise-安全</a><button aria-label="Toggle the collapsible sidebar category &#x27;解析-解释-编译-事件循环-promise-安全&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/html-css/requestAnimationFrame/requestAnimationFrame-是宏任务吗">html-css</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘">http-浏览器缓存</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/http-浏览器缓存/浏览器请求-渲染的流程-回流重绘">浏览器请求-渲染的流程-回流重绘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/浏览器缓存">浏览器缓存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/http1.1-http2.0-报文">http1.1-http2.0-报文</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/reflow-repaint">reflow-repaint</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/TCP-IP-握手">TCP-IP-握手</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/https-加密方式">https-加密方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/跨域-反向代理-正向代理">跨域-反向代理-正向代理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/辅-DNS查询过程-DNS污染-IP封锁">DNS查询过程-DNS污染-IP封锁</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/状态码-请求报文之req header-响应报文res header">状态码-请求报文之req header-响应报文res header</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/鉴权-Token和JWT-cookie-session">鉴权-Token和JWT-cookie-session</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/http-和js-stream">http-和js-stream</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/辅-vpn-vps-Proxy以及shadowsocks之间的联系和区别">vpn-vps-Proxy以及shadowsocks之间的联系和区别</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/http-浏览器缓存/WebSocket-Socks5-shadowsocks/00-1-WebSocket和http异同">WebSocket-Socks5-shadowsocks</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/http-浏览器缓存/websocket/客户端">客户端</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/build-webpack/浏览器正常运行流程-静态-同步">webpack</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/build-AST-Babel/AST">AST-Babel</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/build-monorepo-turbopack/monorepo">monorepo-turbopack</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/ssr服务端渲染-nodejs/react-ssr-demo/react18-ssr">ssr服务端渲染-nodejs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/优化/React">优化</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/C++-V8/v8/v8基础">C++-V8</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/backend/消息队列">backend</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/设计模式/">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/正则/00-1-正则-基础">正则</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">http-浏览器缓存</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">浏览器请求-渲染的流程-回流重绘</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>输入github.com 浏览器的一系列流程</h1><p>简要过程:</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤1-在发起网络请求之前涉及到浏览器静态资源的缓存">步骤1. 在发起网络请求之前,涉及到浏览器静态资源的缓存<a href="#步骤1-在发起网络请求之前涉及到浏览器静态资源的缓存" class="hash-link" aria-label="Direct link to 步骤1. 在发起网络请求之前,涉及到浏览器静态资源的缓存" title="Direct link to 步骤1. 在发起网络请求之前,涉及到浏览器静态资源的缓存">​</a></h2><p><a href="/http-浏览器缓存/浏览器缓存">浏览器缓存</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤2dns域名解析">步骤2.DNS域名解析<a href="#步骤2dns域名解析" class="hash-link" aria-label="Direct link to 步骤2.DNS域名解析" title="Direct link to 步骤2.DNS域名解析">​</a></h2><p>浏览器首先要做的事情就是获得 github.com 的IP地址，具体的做法就是发送一个UDP的包给DNS服务器，DNS服务器会返回 github.com 的IP, 这时候浏览器通常会把IP地址给缓存起来，这样下次访问就会加快。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">chrome://net-internals/#dns</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">可以看到IP地址:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">43.128.224.150</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>使用DNS域名解析（域名和服务器IP对应关系保存在hosts文件中），找到对应服务器IP</li><li>浏览器缓存</li><li>本机缓存</li><li>hosts 文件</li><li>路由器缓存</li><li>ISP DNS 缓存</li><li>DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3建立tcp连接">步骤3.建立TCP连接<a href="#步骤3建立tcp连接" class="hash-link" aria-label="Direct link to 步骤3.建立TCP连接" title="Direct link to 步骤3.建立TCP连接">​</a></h2><p>有了服务器的IP，浏览器就要可以发起HTTP请求了，但是HTTP Request/Response 基于传输层TCP.</p><p>想要建立“虚拟的”TCP连接，TCP邮差需要知道4个东西：</p><ul><li>本机IP</li><li>本机端口</li><li>服务器IP</li><li>服务器端口</li></ul><p>DNS查询后知道了本机IP,服务器IP，本机端口和服务器端口怎么获取？
本机端口操作系统可以给浏览器随机分配一个，服务器端口HTTP服务就是80，我们直接告诉TCP邮差就行。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-1tcp三次握手建立连接">步骤3-1.TCP三次握手建立连接<a href="#步骤3-1tcp三次握手建立连接" class="hash-link" aria-label="Direct link to 步骤3-1.TCP三次握手建立连接" title="Direct link to 步骤3-1.TCP三次握手建立连接">​</a></h3><p><a href="/http-浏览器缓存/TCP-IP-握手">三次握手解析</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-1发送http请求比如get">步骤3-1.发送http请求,比如get<a href="#步骤3-1发送http请求比如get" class="hash-link" aria-label="Direct link to 步骤3-1.发送http请求,比如get" title="Direct link to 步骤3-1.发送http请求,比如get">​</a></h2><p>经过三次握手以后，客户端和服务器端的TCP连接就建立后开始发送HTTP请求 (包括端口路径，请求参数和各种信息),组装一个 HTTP（GET）请求报文</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-2服务处理使用nginx这个web服务器来举例">步骤3-2.服务处理:使用Nginx这个Web服务器来举例<a href="#步骤3-2服务处理使用nginx这个web服务器来举例" class="hash-link" aria-label="Direct link to 步骤3-2.服务处理:使用Nginx这个Web服务器来举例" title="Direct link to 步骤3-2.服务处理:使用Nginx这个Web服务器来举例">​</a></h2><p>一个HTTP GET请求历经多个路由器的转发，到达服务器端,服务器需要着手处理了，它有三种方式来处理：</p><ol><li>可以用一个线程来处理所有请求，同一时刻只能处理一个，这种结构易于实现，但是这样会造成严重的性能问题</li><li>可以为每个请求分配一个进程/线程，但是当连接太多的时候，服务器端的进程/线程会耗费大量内存资源，进程/线程的切换也会让CPU不堪重负。</li><li>复用I/O的方式，很多Web服务器都采用了复用结构，例如通过epoll的方式监视所有的连接，当连接的状态发生变化（如有数据可读）， 才用一个进程/线程对那个连接进行处理，处理完以后继续监视，等待下次状态变化。 用这种方式可以用少量的进程/线程应对成千上万的连接请求。</li></ol><p>对于HTTP GET请求，Nginx利用epoll的方式给读取了出来， Nginx接下来要判断，这是个静态的请求还是个动态的请求</p><ul><li><p>1.静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回</p></li><li><p>2.动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发;</p></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Nginx支持这么几种：</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">1.轮询：按照次序挨个向后端服务器转发</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2.权重：给每个后端服务器指定一个权重，相当于向后端服务器转发的几率。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3.ip_hash： 根据ip做一个hash操作，然后找个服务器转发，这样的话同一个客户端ip总是会转发到同一个后端服务器。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3.fair：根据后端服务器的响应时间来分配请求，响应时间段的优先分配。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">不管用哪种算法，某个后端服务器最终被选中，然后Nginx需要把HTTP Request转发给后端的Tomcat，并且把Tomcat输出的HttpResponse再转发给浏览器。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">由此可见，Nginx在这种场景下，是一个代理人的角色。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-2服务器处理静态请求关于响应缓存">步骤3-2.服务器处理静态请求:关于响应缓存<a href="#步骤3-2服务器处理静态请求关于响应缓存" class="hash-link" aria-label="Direct link to 步骤3-2.服务器处理静态请求:关于响应缓存" title="Direct link to 步骤3-2.服务器处理静态请求:关于响应缓存">​</a></h2><p>服务器看是否需要缓存，服务器处理完请求，发出一个响应（这部分也是重点，请查询资料了解http响应头各个字段的含义）</p><p>服务器检查<code>HTTP 请求头是否包含缓存验证信息</code>如果验证缓存新鲜，返回<code>304</code>等对应状态码</p><p>当服务器给浏览器发送JS,CSS这些文件时，会告诉浏览器这些文件什么时候过期（使用Cache-Control或者Expire），浏览器可以把文件缓存到本地，当第二次请求同样的文件时，如果不过期，直接从本地取就可以了。</p><p>如果过期了，浏览器就可以询问服务器端，文件有没有修改过？（依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not Modified），还可以使用缓存。否则的话服务器就会被最新的文件发回到浏览器。</p><br><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-3服务器处理动态请求">步骤3-3.服务器处理动态请求<a href="#步骤3-3服务器处理动态请求" class="hash-link" aria-label="Direct link to 步骤3-3.服务器处理动态请求" title="Direct link to 步骤3-3.服务器处理动态请求">​</a></h2><p>如同Web服务器一样，Tomcat也可能为每个请求分配一个线程去处理，即通常所说的BIO模式（Blocking I/O 模式）也可能使用I/O多路复用技术，仅仅使用若干线程来处理所有请求，即NIO模式。</p><p>不管用哪种方式，Http Request 都会被交给某个Servlet处理，这个Servlet又会把Http Request做转换，变成框架所使用的参数格式，然后分发给某个Controller(如果你是在用Spring)或者Action(如果你是在Struts)。接下来就是增删改查逻辑，在这个过程中很有可能和缓存、数据库等后端组件打交道，最终返回HTTP Response</p><p>Tomcat把Http Response发给了Nginx。
Nginx把Http Response 发给了浏览器。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤3-4浏览器在与服务器建立了一个tcp连接后是否会在一个-http-请求完成后断开什么情况下会断开">步骤3-4.浏览器在与服务器建立了一个TCP连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？<a href="#步骤3-4浏览器在与服务器建立了一个tcp连接后是否会在一个-http-请求完成后断开什么情况下会断开" class="hash-link" aria-label="Direct link to 步骤3-4.浏览器在与服务器建立了一个TCP连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？" title="Direct link to 步骤3-4.浏览器在与服务器建立了一个TCP连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？">​</a></h2><ul><li><p>在 HTTP 1.0 协议中，通常在一个 HTTP 请求完成后会断开 TCP 连接。这种方式叫做短连接。
但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。</p></li><li><p>HTTP1.1中 这个连接默认是keep-alive，也就是说不能关闭;默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤4浏览器接收http-response">步骤4.浏览器接收http response<a href="#步骤4浏览器接收http-response" class="hash-link" aria-label="Direct link to 步骤4.浏览器接收http response" title="Direct link to 步骤4.浏览器接收http response">​</a></h2><p>如果需要下载的外部资源太多，浏览器会创建多个TCP连接，并行地去下载。
但是同一时间对同一域名下的请求数量也不能太多，要不然服务器访问量太大，受不了。所以浏览器要限制一下， 例如Chrome在Http1.1下只能并行地下载6个资源。</p><ol><li>浏览器检查响应状态码：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</li><li>如果资源可缓存，进行缓存</li><li>对响应进行解码（例如 gzip 压缩）</li><li>根据资源类型决定如何处理（假设资源为 HTML 文档）</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤5浏览器对页面进行渲染执行js代码开始解析资源jscsshtml解析html构建渲染树和开始渲染">步骤5.浏览器对页面进行渲染，执行js代码开始解析资源JS,CSS,HTML，解析HTML构建渲染树和开始渲染<a href="#步骤5浏览器对页面进行渲染执行js代码开始解析资源jscsshtml解析html构建渲染树和开始渲染" class="hash-link" aria-label="Direct link to 步骤5.浏览器对页面进行渲染，执行js代码开始解析资源JS,CSS,HTML，解析HTML构建渲染树和开始渲染" title="Direct link to 步骤5.浏览器对页面进行渲染，执行js代码开始解析资源JS,CSS,HTML，解析HTML构建渲染树和开始渲染">​</a></h2><p>浏览器HTML文件，开始准备显示这个页面。HTML页面中可能引用了大量其他资源，例如js文件，CSS文件，图片等浏览器会分别去下载，从使用DNS获取IP开始，之前做过的事情还要再来一遍。</p><p>浏览器的引擎工作流程大致分为5步：</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤5-1使用html解析器分析html元素构建一颗dom树">步骤5-1.使用HTML解析器，分析HTML元素，构建一颗DOM树<a href="#步骤5-1使用html解析器分析html元素构建一颗dom树" class="hash-link" aria-label="Direct link to 步骤5-1.使用HTML解析器，分析HTML元素，构建一颗DOM树" title="Direct link to 步骤5-1.使用HTML解析器，分析HTML元素，构建一颗DOM树">​</a></h2><p>浏览器解析html代码，当解析时遇到css或js文件，就向服务器请求并下载对应的css文件和js文件</p><p>浏览器把获取到的HTML代码解析成DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏的节点，还有用JS动态添加的元素等。</p><p><img loading="lazy" src="/assets/images/图-浏览器html渲染过程-30a7d569fbd03f2c9c5ce035a08aa276.png" width="590" height="272" class="img_ev3q">
可以发现图中还有一个紫色的DOM三角，实际上这里是js对DOM的相关操作；
在HTML解析时，如果遇到JavaScript标签，就会停止解析HTML，而去加载和执行JavaScript代码；</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="步骤5扩展js解析如下">步骤5扩展js解析如下<a href="#步骤5扩展js解析如下" class="hash-link" aria-label="Direct link to 步骤5扩展js解析如下" title="Direct link to 步骤5扩展js解析如下">​</a></h3><ol><li><p>浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时document.readyState为loading;</p></li><li><p>HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</p></li><li><p>当解析器遇到设置了async属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素</p></li><li><p>当文档完成解析，document.readState 变成 interactive</p></li><li><p>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()</p></li><li><p>浏览器在 Document 对象上触发 DOMContentLoaded 事件</p></li><li><p>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 触发 load 事件</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤5-2使用css解析器分析css文件和元素上的inline样式生成页面的cssom-树">步骤5-2.使用CSS解析器，分析CSS文件和元素上的inline样式，生成页面的CSSOM 树<a href="#步骤5-2使用css解析器分析css文件和元素上的inline样式生成页面的cssom-树" class="hash-link" aria-label="Direct link to 步骤5-2.使用CSS解析器，分析CSS文件和元素上的inline样式，生成页面的CSSOM 树" title="Direct link to 步骤5-2.使用CSS解析器，分析CSS文件和元素上的inline样式，生成页面的CSSOM 树">​</a></h2><p>浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤5-3cssom-与-dom-一起构建渲染树render-tree浏览器依次使用渲染树来布局和绘制网页">步骤5-3.CSSOM 与 DOM 一起构建渲染树(Render Tree)，浏览器依次使用渲染树来布局和绘制网页。<a href="#步骤5-3cssom-与-dom-一起构建渲染树render-tree浏览器依次使用渲染树来布局和绘制网页" class="hash-link" aria-label="Direct link to 步骤5-3.CSSOM 与 DOM 一起构建渲染树(Render Tree)，浏览器依次使用渲染树来布局和绘制网页。" title="Direct link to 步骤5-3.CSSOM 与 DOM 一起构建渲染树(Render Tree)，浏览器依次使用渲染树来布局和绘制网页。">​</a></h2><p>将上面的DOM树和CSSOM tree一起构建构建Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接收样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。</p><p>让我们来具体了解下每一步具体做了什么,为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li>从DOM树的根节点开始遍历每个可见节点。</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">render tree中每个NODE都有自己的style，render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">1.一些不会渲染输出的节点，比如script、meta、link等。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2.一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。因为visibility:hidden 会影响布局(layout)，会占有空间。</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">总结:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">只有display:none的节点才不会显示在渲染树上。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p><img loading="lazy" src="/assets/images/图7-生成渲染树-ca35a35e11c445f454bca6d15523bae9.png" width="732" height="340" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤6有了render树后浏览器开始布局会为每个render树上的节点确定一个在显示屏上出现的精确坐标值">步骤6.有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值<a href="#步骤6有了render树后浏览器开始布局会为每个render树上的节点确定一个在显示屏上出现的精确坐标值" class="hash-link" aria-label="Direct link to 步骤6.有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值" title="Direct link to 步骤6.有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值">​</a></h2><p>这里涉及回流,每个页面至少需要一次回流，就是在页面第一次加载的时候;
在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后,下一步就是绘制。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-1-render树和节点显示的位置坐标也有了最后就是调用每个节点的paint方法让它们显示出来">6-1. Render树和节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。<a href="#6-1-render树和节点显示的位置坐标也有了最后就是调用每个节点的paint方法让它们显示出来" class="hash-link" aria-label="Direct link to 6-1. Render树和节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。" title="Direct link to 6-1. Render树和节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。">​</a></h2><p>正式渲染:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。</p><p><a href="/http-浏览器缓存/reflow-repaint">reflow-repaint</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-javascript可能修改dom-tree">7. JavaScript可能修改DOM Tree<a href="#7-javascript可能修改dom-tree" class="hash-link" aria-label="Direct link to 7. JavaScript可能修改DOM Tree" title="Direct link to 7. JavaScript可能修改DOM Tree">​</a></h2><p><img loading="lazy" src="/assets/images/图6-浏览器的渲染过程-aaa61721f358d5563ef6ef1447859de6.png" width="632" height="306" class="img_ev3q">
<img loading="lazy" src="/assets/images/A-抽离出来方便看-浏览器渲染过程-85d4657c7056bd99fbe1230222d8cd7a.PNG" width="768" height="656" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="最后显示页面html-解析过程中会逐步显示页面">最后显示页面（HTML 解析过程中会逐步显示页面）<a href="#最后显示页面html-解析过程中会逐步显示页面" class="hash-link" aria-label="Direct link to 最后显示页面（HTML 解析过程中会逐步显示页面）" title="Direct link to 最后显示页面（HTML 解析过程中会逐步显示页面）">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="释放连接四次">释放连接四次<a href="#释放连接四次" class="hash-link" aria-label="Direct link to 释放连接四次" title="Direct link to 释放连接四次">​</a></h2></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/huiruo/programming-tech-website/programming-tech/http-浏览器缓存/01-浏览器请求-渲染的流程-回流重绘.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/html-css/webgl3d/webgl与canvas-性能-动画区别"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">webgl与canvas-性能-动画区别</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/http-浏览器缓存/浏览器缓存"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">浏览器缓存</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#步骤1-在发起网络请求之前涉及到浏览器静态资源的缓存" class="table-of-contents__link toc-highlight">步骤1. 在发起网络请求之前,涉及到浏览器静态资源的缓存</a></li><li><a href="#步骤2dns域名解析" class="table-of-contents__link toc-highlight">步骤2.DNS域名解析</a></li><li><a href="#步骤3建立tcp连接" class="table-of-contents__link toc-highlight">步骤3.建立TCP连接</a><ul><li><a href="#步骤3-1tcp三次握手建立连接" class="table-of-contents__link toc-highlight">步骤3-1.TCP三次握手建立连接</a></li></ul></li><li><a href="#步骤3-1发送http请求比如get" class="table-of-contents__link toc-highlight">步骤3-1.发送http请求,比如get</a></li><li><a href="#步骤3-2服务处理使用nginx这个web服务器来举例" class="table-of-contents__link toc-highlight">步骤3-2.服务处理:使用Nginx这个Web服务器来举例</a></li><li><a href="#步骤3-2服务器处理静态请求关于响应缓存" class="table-of-contents__link toc-highlight">步骤3-2.服务器处理静态请求:关于响应缓存</a></li><li><a href="#步骤3-3服务器处理动态请求" class="table-of-contents__link toc-highlight">步骤3-3.服务器处理动态请求</a></li><li><a href="#步骤3-4浏览器在与服务器建立了一个tcp连接后是否会在一个-http-请求完成后断开什么情况下会断开" class="table-of-contents__link toc-highlight">步骤3-4.浏览器在与服务器建立了一个TCP连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</a></li><li><a href="#步骤4浏览器接收http-response" class="table-of-contents__link toc-highlight">步骤4.浏览器接收http response</a></li><li><a href="#步骤5浏览器对页面进行渲染执行js代码开始解析资源jscsshtml解析html构建渲染树和开始渲染" class="table-of-contents__link toc-highlight">步骤5.浏览器对页面进行渲染，执行js代码开始解析资源JS,CSS,HTML，解析HTML构建渲染树和开始渲染</a></li><li><a href="#步骤5-1使用html解析器分析html元素构建一颗dom树" class="table-of-contents__link toc-highlight">步骤5-1.使用HTML解析器，分析HTML元素，构建一颗DOM树</a><ul><li><a href="#步骤5扩展js解析如下" class="table-of-contents__link toc-highlight">步骤5扩展js解析如下</a></li></ul></li><li><a href="#步骤5-2使用css解析器分析css文件和元素上的inline样式生成页面的cssom-树" class="table-of-contents__link toc-highlight">步骤5-2.使用CSS解析器，分析CSS文件和元素上的inline样式，生成页面的CSSOM 树</a></li><li><a href="#步骤5-3cssom-与-dom-一起构建渲染树render-tree浏览器依次使用渲染树来布局和绘制网页" class="table-of-contents__link toc-highlight">步骤5-3.CSSOM 与 DOM 一起构建渲染树(Render Tree)，浏览器依次使用渲染树来布局和绘制网页。</a></li><li><a href="#步骤6有了render树后浏览器开始布局会为每个render树上的节点确定一个在显示屏上出现的精确坐标值" class="table-of-contents__link toc-highlight">步骤6.有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值</a></li><li><a href="#6-1-render树和节点显示的位置坐标也有了最后就是调用每个节点的paint方法让它们显示出来" class="table-of-contents__link toc-highlight">6-1. Render树和节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。</a></li><li><a href="#7-javascript可能修改dom-tree" class="table-of-contents__link toc-highlight">7. JavaScript可能修改DOM Tree</a></li><li><a href="#最后显示页面html-解析过程中会逐步显示页面" class="table-of-contents__link toc-highlight">最后显示页面（HTML 解析过程中会逐步显示页面）</a></li><li><a href="#释放连接四次" class="table-of-contents__link toc-highlight">释放连接四次</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.654f7f82.js"></script>
<script src="/assets/js/main.0a662770.js"></script>
</body>
</html>